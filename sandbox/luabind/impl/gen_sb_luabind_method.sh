#!/bin/sh

GUARD="SB_LUABIND_METHOD_H_INCLUDED"
MAXARGS=8

echo "#ifndef $GUARD" 
echo "#define $GUARD" 
echo
echo "/**"
echo "	generated by $0 at $(date)"
echo "*/"
echo "#include \"../sb_luabind_stack.h\""
echo "namespace Sandbox {"
echo "	namespace luabind { namespace impl {"
echo "		template <typename FuncPtr,int base=1> struct method_helper;"
echo "		template <typename Proto,int base=1> struct constructor_helper;"
for (( args=0; args<=$MAXARGS; args++ ))
do
	echo "		// implementation for $args args"
	tmpl_args=""
	func_args=""
	call_args=""
	call1_args=""
	for (( i=1; i<=$args; i++ ))
	do
		tmpl_args="$tmpl_args""typename A$i,\n			 "
		if [ $func_args"x" != "x" ]; then
			func_args="$func_args,"
			call_args="$call_args,\n					"
			call1_args="$call1_args,\n					"
		fi
		func_args="$func_args""A$i"
		call_args="$call_args""stack<A$i>::get(L,base+$i-1)"
		call1_args="$call1_args""stack<A$i>::get(L,base+$i)"
	done
	tmpl_args="$tmpl_args""int base"
	
	if [ "x$args" == "x0" ]; then
		echo "		// constructor"
		echo "		template<$tmpl_args>"
		echo "		struct constructor_helper<void($func_args),base>{"
		echo "			template <class T> static T* raw( lua_State * /*L*/) {"
		echo "				return new T();"
		echo "			}"
		echo "			template <class T> static void inplace( lua_State * /*L*/,void *data) {"
		echo "				new (data) T();"
		echo "			}"
		echo "		};"
	else
		echo "		// constructor"
		echo "		template<$tmpl_args>"
		echo "		struct constructor_helper<void($func_args),base>{"
		echo "			template <class T> static T* raw( lua_State * L) {"
		echo "				return new T($call_args);"
		echo "			}"
		echo "			template <class T> static void inplace( lua_State * L,void *data) {"
		echo "				new (data) T($call_args);"
		echo "			}"
		echo "		};"
	fi
	
	echo "		// free method void"
	echo "		template<$tmpl_args>"
	echo "		struct method_helper<void(*)($func_args),base>{"
	echo "			typedef void (*Func)($func_args);"
	echo "			static int call( lua_State* L ) {"
	echo "				Func func = *reinterpret_cast<Func*>(lua_touserdata(L, lua_upvalueindex(1)));"
	echo "				(*func)($call_args);"
	echo "				return 0;"
	echo "			}"
	echo "		};"
	
	echo "		// free method with result"
	echo "		template<class R,$tmpl_args>"
	echo "		struct method_helper<R(*)($func_args),base>{"
	echo "			typedef R (*Func)($func_args);"
	echo "			static int call( lua_State* L ) {"
	echo "				Func func = *reinterpret_cast<Func*>(lua_touserdata(L, lua_upvalueindex(1)));"
	echo "				stack<R>::push(L,(*func)($call_args));"
	echo "				return 1;"
	echo "			}"
	echo "		};"
	
	echo "		// member method void"
	echo "		template<class T,$tmpl_args>"
	echo "		struct method_helper<void(T::*)($func_args),base>{"
	echo "			typedef void (T::*Func)($func_args);"
	echo "			static int call( lua_State* L ) {"
	echo "				Func func = *reinterpret_cast<Func*>(lua_touserdata(L, lua_upvalueindex(1)));"
	echo "				(stack<T*>::get(L,base+0,false)->*func)($call1_args);"
	echo "				return 0;"
	echo "			}"
	echo "		};"
	
	echo "		// member method void const"
	echo "		template<class T,$tmpl_args>"
	echo "		struct method_helper<void(T::*)($func_args)const,base>{"
	echo "			typedef void (T::*Func)($func_args)const;"
	echo "			static int call( lua_State* L ) {"
	echo "				Func func = *reinterpret_cast<Func*>(lua_touserdata(L, lua_upvalueindex(1)));"
	echo "				(stack<const T*>::get(L,base+0,false)->*func)($call1_args);"
	echo "				return 0;"
	echo "			}"
	echo "		};"
	
	echo "		// member method with result"
	echo "		template<class T,class R,$tmpl_args>"
	echo "		struct method_helper<R(T::*)($func_args),base>{"
	echo "			typedef R (T::*Func)($func_args);"
	echo "			static int call( lua_State* L ) {"
	echo "				Func func = *reinterpret_cast<Func*>(lua_touserdata(L, lua_upvalueindex(1)));"
	echo "				stack<R>::push(L,(stack<T*>::get(L,base+0,false)->*func)($call1_args));"
	echo "				return 1;"
	echo "			}"
	echo "		};"
	
	echo "		// member method with result const"
	echo "		template<class T,class R,$tmpl_args>"
	echo "		struct method_helper<R(T::*)($func_args)const,base>{"
	echo "			typedef R (T::*Func)($func_args)const;"
	echo "			static int call( lua_State* L ) {"
	echo "				Func func = *reinterpret_cast<Func*>(lua_touserdata(L, lua_upvalueindex(1)));"
	echo "				stack<R>::push(L,(stack<const T*>::get(L,base+0,false)->*func)($call1_args));"
	echo "				return 1;"
	echo "			}"
	echo "		};"
	
	
done
echo "	} }"
echo "}"
echo "#endif /*$GUARD*/" 