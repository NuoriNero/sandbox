#ifndef SB_LUABIND_WRAPPER_BASE_H_INCLUDED
#define SB_LUABIND_WRAPPER_BASE_H_INCLUDED

/**
	generated by ./gen_sb_luabind_wrapper_base.sh at Sun Jul 15 07:03:50 MSK 2012
*/
#include "sb_luabind_stack.h"
namespace Sandbox {
	namespace luabind { namespace impl {
		template <class Holder>
		class wrapper_base {
		protected:
			Holder	m_self;
		protected:
			// implementation for 0 args
			// void method void
			void call(const char* name){
				lua_State* L = m_self.GetVM();
				m_self.push(L);
				lua_pushstring(L,name);
				lua_gettable(L,-2);
				lua_remove(L,-2);
				if (!lua_isfunction(L,-1)) {
					sb_assert(false);
					return;
				}
				m_self.push(L);
				lua_pcall(L,1,0,0);
			}
			// res method void
			template<class R>
			R call(const char* name,R* = 0){
				lua_State* L = m_self.GetVM();
				m_self.push(L);
				lua_pushstring(L,name);
				lua_gettable(L,-2);
				lua_remove(L,-2);
				if (!lua_isfunction(L,-1)) {
					sb_assert(false);
					return R();
				}
				m_self.push(L);
				lua_pcall(L,1,1,0);
				R res = stack<R>::get(L,-1);
				lua_pop(L,1);
				return res;
			}
			// implementation for 1 args
			// void method void
			template<typename A1>
			void call(const char* name,typename sb::type_traits<A1>::parameter_type a1){
				lua_State* L = m_self.GetVM();
				m_self.push(L);
				lua_pushstring(L,name);
				lua_gettable(L,-2);
				lua_remove(L,-2);
				if (!lua_isfunction(L,-1)) {
					sb_assert(false);
					return;
				}
				m_self.push(L);
				stack<A1>::push(L,a1);
				lua_pcall(L,1+1,0,0);
			}
			// res method void
			template<class R,typename A1>
			R call(const char* name,typename sb::type_traits<A1>::parameter_type a1,R* = 0){
				lua_State* L = m_self.GetVM();
				m_self.push(L);
				lua_pushstring(L,name);
				lua_gettable(L,-2);
				lua_remove(L,-2);
				if (!lua_isfunction(L,-1)) {
					sb_assert(false);
					return R();
				}
				m_self.push(L);
				stack<A1>::push(L,a1);
				lua_pcall(L,1+1,1,0);
				R res = stack<R>::get(L,-1);
				lua_pop(L,1);
				return res;
			}
			// implementation for 2 args
			// void method void
			template<typename A1,
				typename A2>
			void call(const char* name,typename sb::type_traits<A1>::parameter_type a1,
						typename sb::type_traits<A2>::parameter_type a2){
				lua_State* L = m_self.GetVM();
				m_self.push(L);
				lua_pushstring(L,name);
				lua_gettable(L,-2);
				lua_remove(L,-2);
				if (!lua_isfunction(L,-1)) {
					sb_assert(false);
					return;
				}
				m_self.push(L);
				stack<A1>::push(L,a1);
				stack<A2>::push(L,a2);
				lua_pcall(L,1+2,0,0);
			}
			// res method void
			template<class R,typename A1,
				typename A2>
			R call(const char* name,typename sb::type_traits<A1>::parameter_type a1,
						typename sb::type_traits<A2>::parameter_type a2,R* = 0){
				lua_State* L = m_self.GetVM();
				m_self.push(L);
				lua_pushstring(L,name);
				lua_gettable(L,-2);
				lua_remove(L,-2);
				if (!lua_isfunction(L,-1)) {
					sb_assert(false);
					return R();
				}
				m_self.push(L);
				stack<A1>::push(L,a1);
				stack<A2>::push(L,a2);
				lua_pcall(L,1+2,1,0);
				R res = stack<R>::get(L,-1);
				lua_pop(L,1);
				return res;
			}
			// implementation for 3 args
			// void method void
			template<typename A1,
				typename A2,
				typename A3>
			void call(const char* name,typename sb::type_traits<A1>::parameter_type a1,
						typename sb::type_traits<A2>::parameter_type a2,
						typename sb::type_traits<A3>::parameter_type a3){
				lua_State* L = m_self.GetVM();
				m_self.push(L);
				lua_pushstring(L,name);
				lua_gettable(L,-2);
				lua_remove(L,-2);
				if (!lua_isfunction(L,-1)) {
					sb_assert(false);
					return;
				}
				m_self.push(L);
				stack<A1>::push(L,a1);
				stack<A2>::push(L,a2);
				stack<A3>::push(L,a3);
				lua_pcall(L,1+3,0,0);
			}
			// res method void
			template<class R,typename A1,
				typename A2,
				typename A3>
			R call(const char* name,typename sb::type_traits<A1>::parameter_type a1,
						typename sb::type_traits<A2>::parameter_type a2,
						typename sb::type_traits<A3>::parameter_type a3,R* = 0){
				lua_State* L = m_self.GetVM();
				m_self.push(L);
				lua_pushstring(L,name);
				lua_gettable(L,-2);
				lua_remove(L,-2);
				if (!lua_isfunction(L,-1)) {
					sb_assert(false);
					return R();
				}
				m_self.push(L);
				stack<A1>::push(L,a1);
				stack<A2>::push(L,a2);
				stack<A3>::push(L,a3);
				lua_pcall(L,1+3,1,0);
				R res = stack<R>::get(L,-1);
				lua_pop(L,1);
				return res;
			}
			// implementation for 4 args
			// void method void
			template<typename A1,
				typename A2,
				typename A3,
				typename A4>
			void call(const char* name,typename sb::type_traits<A1>::parameter_type a1,
						typename sb::type_traits<A2>::parameter_type a2,
						typename sb::type_traits<A3>::parameter_type a3,
						typename sb::type_traits<A4>::parameter_type a4){
				lua_State* L = m_self.GetVM();
				m_self.push(L);
				lua_pushstring(L,name);
				lua_gettable(L,-2);
				lua_remove(L,-2);
				if (!lua_isfunction(L,-1)) {
					sb_assert(false);
					return;
				}
				m_self.push(L);
				stack<A1>::push(L,a1);
				stack<A2>::push(L,a2);
				stack<A3>::push(L,a3);
				stack<A4>::push(L,a4);
				lua_pcall(L,1+4,0,0);
			}
			// res method void
			template<class R,typename A1,
				typename A2,
				typename A3,
				typename A4>
			R call(const char* name,typename sb::type_traits<A1>::parameter_type a1,
						typename sb::type_traits<A2>::parameter_type a2,
						typename sb::type_traits<A3>::parameter_type a3,
						typename sb::type_traits<A4>::parameter_type a4,R* = 0){
				lua_State* L = m_self.GetVM();
				m_self.push(L);
				lua_pushstring(L,name);
				lua_gettable(L,-2);
				lua_remove(L,-2);
				if (!lua_isfunction(L,-1)) {
					sb_assert(false);
					return R();
				}
				m_self.push(L);
				stack<A1>::push(L,a1);
				stack<A2>::push(L,a2);
				stack<A3>::push(L,a3);
				stack<A4>::push(L,a4);
				lua_pcall(L,1+4,1,0);
				R res = stack<R>::get(L,-1);
				lua_pop(L,1);
				return res;
			}
			// implementation for 5 args
			// void method void
			template<typename A1,
				typename A2,
				typename A3,
				typename A4,
				typename A5>
			void call(const char* name,typename sb::type_traits<A1>::parameter_type a1,
						typename sb::type_traits<A2>::parameter_type a2,
						typename sb::type_traits<A3>::parameter_type a3,
						typename sb::type_traits<A4>::parameter_type a4,
						typename sb::type_traits<A5>::parameter_type a5){
				lua_State* L = m_self.GetVM();
				m_self.push(L);
				lua_pushstring(L,name);
				lua_gettable(L,-2);
				lua_remove(L,-2);
				if (!lua_isfunction(L,-1)) {
					sb_assert(false);
					return;
				}
				m_self.push(L);
				stack<A1>::push(L,a1);
				stack<A2>::push(L,a2);
				stack<A3>::push(L,a3);
				stack<A4>::push(L,a4);
				stack<A5>::push(L,a5);
				lua_pcall(L,1+5,0,0);
			}
			// res method void
			template<class R,typename A1,
				typename A2,
				typename A3,
				typename A4,
				typename A5>
			R call(const char* name,typename sb::type_traits<A1>::parameter_type a1,
						typename sb::type_traits<A2>::parameter_type a2,
						typename sb::type_traits<A3>::parameter_type a3,
						typename sb::type_traits<A4>::parameter_type a4,
						typename sb::type_traits<A5>::parameter_type a5,R* = 0){
				lua_State* L = m_self.GetVM();
				m_self.push(L);
				lua_pushstring(L,name);
				lua_gettable(L,-2);
				lua_remove(L,-2);
				if (!lua_isfunction(L,-1)) {
					sb_assert(false);
					return R();
				}
				m_self.push(L);
				stack<A1>::push(L,a1);
				stack<A2>::push(L,a2);
				stack<A3>::push(L,a3);
				stack<A4>::push(L,a4);
				stack<A5>::push(L,a5);
				lua_pcall(L,1+5,1,0);
				R res = stack<R>::get(L,-1);
				lua_pop(L,1);
				return res;
			}
			// implementation for 6 args
			// void method void
			template<typename A1,
				typename A2,
				typename A3,
				typename A4,
				typename A5,
				typename A6>
			void call(const char* name,typename sb::type_traits<A1>::parameter_type a1,
						typename sb::type_traits<A2>::parameter_type a2,
						typename sb::type_traits<A3>::parameter_type a3,
						typename sb::type_traits<A4>::parameter_type a4,
						typename sb::type_traits<A5>::parameter_type a5,
						typename sb::type_traits<A6>::parameter_type a6){
				lua_State* L = m_self.GetVM();
				m_self.push(L);
				lua_pushstring(L,name);
				lua_gettable(L,-2);
				lua_remove(L,-2);
				if (!lua_isfunction(L,-1)) {
					sb_assert(false);
					return;
				}
				m_self.push(L);
				stack<A1>::push(L,a1);
				stack<A2>::push(L,a2);
				stack<A3>::push(L,a3);
				stack<A4>::push(L,a4);
				stack<A5>::push(L,a5);
				stack<A6>::push(L,a6);
				lua_pcall(L,1+6,0,0);
			}
			// res method void
			template<class R,typename A1,
				typename A2,
				typename A3,
				typename A4,
				typename A5,
				typename A6>
			R call(const char* name,typename sb::type_traits<A1>::parameter_type a1,
						typename sb::type_traits<A2>::parameter_type a2,
						typename sb::type_traits<A3>::parameter_type a3,
						typename sb::type_traits<A4>::parameter_type a4,
						typename sb::type_traits<A5>::parameter_type a5,
						typename sb::type_traits<A6>::parameter_type a6,R* = 0){
				lua_State* L = m_self.GetVM();
				m_self.push(L);
				lua_pushstring(L,name);
				lua_gettable(L,-2);
				lua_remove(L,-2);
				if (!lua_isfunction(L,-1)) {
					sb_assert(false);
					return R();
				}
				m_self.push(L);
				stack<A1>::push(L,a1);
				stack<A2>::push(L,a2);
				stack<A3>::push(L,a3);
				stack<A4>::push(L,a4);
				stack<A5>::push(L,a5);
				stack<A6>::push(L,a6);
				lua_pcall(L,1+6,1,0);
				R res = stack<R>::get(L,-1);
				lua_pop(L,1);
				return res;
			}
			// implementation for 7 args
			// void method void
			template<typename A1,
				typename A2,
				typename A3,
				typename A4,
				typename A5,
				typename A6,
				typename A7>
			void call(const char* name,typename sb::type_traits<A1>::parameter_type a1,
						typename sb::type_traits<A2>::parameter_type a2,
						typename sb::type_traits<A3>::parameter_type a3,
						typename sb::type_traits<A4>::parameter_type a4,
						typename sb::type_traits<A5>::parameter_type a5,
						typename sb::type_traits<A6>::parameter_type a6,
						typename sb::type_traits<A7>::parameter_type a7){
				lua_State* L = m_self.GetVM();
				m_self.push(L);
				lua_pushstring(L,name);
				lua_gettable(L,-2);
				lua_remove(L,-2);
				if (!lua_isfunction(L,-1)) {
					sb_assert(false);
					return;
				}
				m_self.push(L);
				stack<A1>::push(L,a1);
				stack<A2>::push(L,a2);
				stack<A3>::push(L,a3);
				stack<A4>::push(L,a4);
				stack<A5>::push(L,a5);
				stack<A6>::push(L,a6);
				stack<A7>::push(L,a7);
				lua_pcall(L,1+7,0,0);
			}
			// res method void
			template<class R,typename A1,
				typename A2,
				typename A3,
				typename A4,
				typename A5,
				typename A6,
				typename A7>
			R call(const char* name,typename sb::type_traits<A1>::parameter_type a1,
						typename sb::type_traits<A2>::parameter_type a2,
						typename sb::type_traits<A3>::parameter_type a3,
						typename sb::type_traits<A4>::parameter_type a4,
						typename sb::type_traits<A5>::parameter_type a5,
						typename sb::type_traits<A6>::parameter_type a6,
						typename sb::type_traits<A7>::parameter_type a7,R* = 0){
				lua_State* L = m_self.GetVM();
				m_self.push(L);
				lua_pushstring(L,name);
				lua_gettable(L,-2);
				lua_remove(L,-2);
				if (!lua_isfunction(L,-1)) {
					sb_assert(false);
					return R();
				}
				m_self.push(L);
				stack<A1>::push(L,a1);
				stack<A2>::push(L,a2);
				stack<A3>::push(L,a3);
				stack<A4>::push(L,a4);
				stack<A5>::push(L,a5);
				stack<A6>::push(L,a6);
				stack<A7>::push(L,a7);
				lua_pcall(L,1+7,1,0);
				R res = stack<R>::get(L,-1);
				lua_pop(L,1);
				return res;
			}
			// implementation for 8 args
			// void method void
			template<typename A1,
				typename A2,
				typename A3,
				typename A4,
				typename A5,
				typename A6,
				typename A7,
				typename A8>
			void call(const char* name,typename sb::type_traits<A1>::parameter_type a1,
						typename sb::type_traits<A2>::parameter_type a2,
						typename sb::type_traits<A3>::parameter_type a3,
						typename sb::type_traits<A4>::parameter_type a4,
						typename sb::type_traits<A5>::parameter_type a5,
						typename sb::type_traits<A6>::parameter_type a6,
						typename sb::type_traits<A7>::parameter_type a7,
						typename sb::type_traits<A8>::parameter_type a8){
				lua_State* L = m_self.GetVM();
				m_self.push(L);
				lua_pushstring(L,name);
				lua_gettable(L,-2);
				lua_remove(L,-2);
				if (!lua_isfunction(L,-1)) {
					sb_assert(false);
					return;
				}
				m_self.push(L);
				stack<A1>::push(L,a1);
				stack<A2>::push(L,a2);
				stack<A3>::push(L,a3);
				stack<A4>::push(L,a4);
				stack<A5>::push(L,a5);
				stack<A6>::push(L,a6);
				stack<A7>::push(L,a7);
				stack<A8>::push(L,a8);
				lua_pcall(L,1+8,0,0);
			}
			// res method void
			template<class R,typename A1,
				typename A2,
				typename A3,
				typename A4,
				typename A5,
				typename A6,
				typename A7,
				typename A8>
			R call(const char* name,typename sb::type_traits<A1>::parameter_type a1,
						typename sb::type_traits<A2>::parameter_type a2,
						typename sb::type_traits<A3>::parameter_type a3,
						typename sb::type_traits<A4>::parameter_type a4,
						typename sb::type_traits<A5>::parameter_type a5,
						typename sb::type_traits<A6>::parameter_type a6,
						typename sb::type_traits<A7>::parameter_type a7,
						typename sb::type_traits<A8>::parameter_type a8,R* = 0){
				lua_State* L = m_self.GetVM();
				m_self.push(L);
				lua_pushstring(L,name);
				lua_gettable(L,-2);
				lua_remove(L,-2);
				if (!lua_isfunction(L,-1)) {
					sb_assert(false);
					return R();
				}
				m_self.push(L);
				stack<A1>::push(L,a1);
				stack<A2>::push(L,a2);
				stack<A3>::push(L,a3);
				stack<A4>::push(L,a4);
				stack<A5>::push(L,a5);
				stack<A6>::push(L,a6);
				stack<A7>::push(L,a7);
				stack<A8>::push(L,a8);
				lua_pcall(L,1+8,1,0);
				R res = stack<R>::get(L,-1);
				lua_pop(L,1);
				return res;
			}
		};
	} }
}
#endif /*SB_LUABIND_WRAPPER_BASE_H_INCLUDED*/
